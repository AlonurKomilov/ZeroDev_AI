import shutil
import subprocess
import tempfile
import uuid
from pathlib import Path

from backend.services.project_storage import project_storage_service


class ReviewAgent:
    """
    Performs automated quality checks on the patch file generated by the
    Code Patch Agent. It runs static analysis (linting) and executes
    relevant integration tests in a secure sandbox environment.
    """

    def review_patch(self, user_id: str, project_id: str, diff_patch: str) -> dict:
        """
        Reviews a diff patch by applying it to a sandboxed copy of the project
        and running validation checks.

        :param user_id: The ID of the user.
        :param project_id: The ID of the project.
        :param diff_patch: The diff patch string to be applied and reviewed.
        :return: A dictionary containing the review results.
        """
        print(f"Starting review for project: {project_id}")
        source_project_path = project_storage_service.get_project_path(
            uuid.UUID(user_id), uuid.UUID(project_id)
        )

        if not source_project_path.exists():
            return {"success": False, "error": "Source project path does not exist."}

        # 1. Create a temporary sandbox environment.
        with tempfile.TemporaryDirectory() as temp_dir:
            sandbox_path = Path(temp_dir) / "project"
            try:
                shutil.copytree(source_project_path, sandbox_path)
                print(f"Created sandbox at: {sandbox_path}")
            except Exception as e:
                return {"success": False, "error": f"Failed to create sandbox: {e}"}

            # 2. Apply the patch.
            patch_file_path = sandbox_path / "changes.patch"
            with open(patch_file_path, "w") as f:
                f.write(diff_patch)

            # The `patch` command is a standard Unix utility.
            # -p1 strips the 'a/' and 'b/' prefixes from the file paths in the diff.
            apply_command = ["patch", "-p1", "-i", str(patch_file_path)]
            try:
                # We run this from within the sandboxed project directory.
                result = subprocess.run(
                    apply_command,
                    cwd=sandbox_path,
                    capture_output=True,
                    text=True,
                    check=True,
                )
                print("Patch applied successfully.")
                print(result.stdout)
            except (subprocess.CalledProcessError, FileNotFoundError) as e:
                error_message = f"Failed to apply patch: {e}"
                if hasattr(e, "stderr"):
                    error_message += f"\nStderr: {e.stderr}"
                print(error_message)
                return {"success": False, "error": error_message}

            # 3. Run static analysis (linting) - Placeholder
            # In a real implementation, we would detect the project type and run
            # appropriate linters (e.g., flake8 for Python, ESLint for JS).
            linting_result = self._run_linting(sandbox_path)
            if not linting_result["success"]:
                return linting_result

            # 4. Execute integration tests - Placeholder
            # This would involve detecting the test framework (e.g., pytest, jest)
            # and running the relevant test suite.
            test_result = self._run_tests(sandbox_path)
            if not test_result["success"]:
                return test_result

            print(f"Review completed successfully for project: {project_id}")
            return {
                "success": True,
                "details": "Patch applied, linted, and tested successfully.",
            }

    def _run_linting(self, project_path: Path) -> dict:
        """Placeholder for running linters."""
        print("Skipping linting (placeholder).")
        # Example for a Python project:
        # try:
        #     subprocess.run(["flake8", "."], cwd=project_path, check=True, capture_output=True, text=True)
        #     return {"success": True}
        # except subprocess.CalledProcessError as e:
        #     return {"success": False, "error": f"Linting failed: {e.stdout}"}
        return {"success": True}

    def _run_tests(self, project_path: Path) -> dict:
        """Placeholder for running tests."""
        print("Skipping tests (placeholder).")
        # Example for a Python project with pytest:
        # try:
        #     subprocess.run(["pytest"], cwd=project_path, check=True, capture_output=True, text=True)
        #     return {"success": True}
        # except subprocess.CalledProcessError as e:
        #     return {"success": False, "error": f"Tests failed: {e.stdout}"}
        return {"success": True}


# Singleton instance of the agent
review_agent = ReviewAgent()
